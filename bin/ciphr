#!/usr/bin/env ruby

require 'ciphr'
require 'slop'



Slop.parse do
  banner "Usage: #{File.basename $0} [options] [spec]"
  on :h, :help
  on :v, :verbose
  on :n, :'no-newline'
  on :N, :'newline'

  run do |opts, args|

    Ciphr::Functions.setup
    if opts[:help] || args.size == 0
        puts opts
        
        if opts[:verbose]
            puts "Available Functions: aliases ([args])"
            Ciphr::Functions.functions.flat_map{|c,vs| vs.map{|v| [c,v] }}.each{|a|
                c,v = a
                puts "  #{v[0].map{|v|v.to_s}.join(", ")} (#{c.params.map{|p| p.to_s}.join(", ")})"
            }
        end
    else
      newline = opts[:newline] || STDOUT.tty? && ! opts[:'no-newline']
      spec = args.join(" ")
      begin
        parsed = Ciphr::Parser.new.parse(spec)
        transformed = Ciphr::Transformer.new($stdin).apply(parsed)
     
        while chunk = transformed.read(256)
          $stdout.print chunk
        end
        puts if newline 
      rescue Parslet::ParseFailed => e
        $stderr.puts e.cause
        $stderr.puts spec
        $stderr.puts " "*(e.cause.pos) + "^"
      rescue Ciphr::Functions::InvalidFunctionError => e
        $stderr.puts "invalid function '#{e.name}'"
      end
    end
  end
end




