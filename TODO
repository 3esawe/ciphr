TODO:
==========================
fix
-----------
zero/default IV for ciphers; should be random

robustness
-----------
* graceful handling of mismatched data size (key size, base64 chunks, xor)
* errors for bad function name or args
* case insensitivity for ~b16
* high level classification of functions (util, bitwise, hash, cipher, mac, etc)
* handling of optional arguments (IVs/nonces, # rounds, etc) without breaking pipe argument prepending

completeness
-----------
base64 variants
* %/url, b32, ascii85, escape-sequence (\x, String.dump), xml/html, unicode encoding, other stuff in ruby's Encoding class
* bitwise ops: variants for mismatched lengths?


features
---------------
functions
  bitwise ops
    shift right/left (circular rotate vs fill)
    not/and/or (similar to xor)
  hashes  
    crc/adler
    crypt/scrypt/bcrypt/pbkdf
  ciphers
    substitution: caeser/rot/dvorak/vigen√®re
  byte ops
    prepend/append
    indexed head/tail/substring
    reverse bits/nibbles/bytes	
    repeat bytes
  compression
    gzip/deflate/lz*/bzip2/snappy/rle
      http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv
  generators
    random bytes

revamp streams
  http://readruby.io/io
  https://github.com/javanthropus/io-like
  https://github.com/javanthropus/stream
  https://github.com/rubygems/rubygems/blob/master/lib/rubygems/package/digest_io.rb
  https://www.ruby-forum.com/topic/58563
namespacing in case of simple name collisions
string literals
  alternative quotes (a la ruby/perl/python, %q[] %Q{} qq() """ ''') http://en.wikibooks.org/wiki/Ruby_Programming/Alternate_quotes
  allow \xXX escaping
extension mechanism (via other gems or simple files)
non pipe statements
variable writing/reading


random ideas
-------------
`strings` extraction
regex search/replace support
fn for executing shell/ruby
multi-round hash support


cleanliness
-----------
refactor variable buffering (probably will improve perf)
break up functions


scratch notes
==========================

$ ruby -e 'puts ["c","s"].product(["i","y"]).product(["ph","f"]).product(["r","er","yr","ir"]).map{|a| a.flatten.join}'
ciphr
cipher
ciphyr
ciphir
cifr
cifer
cifyr
cifir
cyphr
cypher
cyphyr
cyphir
cyfr
cyfer
cyfyr
cyfir
siphr
sipher
siphyr
siphir
sifr
sifer
sifyr
sifir
syphr
sypher
syphyr
syphir
syfr
syfer
syfyr
syfir


11111111 | 11111111 | 11111111
111 | 111 | 111 | 111 | 111 | 111 | 111 | 111 

1 2 3 4 5 6 7 8*1 2 3 4 5 6 7 8*1 2 3 4 5 6 7 8
1 2 3*1 2 3*1 2 3*1 2 3*1 2 3*1 2 3*1 2 3*1 2 3


~b64,hmac(abcd,~b64),b16,xor(deef,~b64)
~des

=abcd/^hex/b64/hmac[=abcd/^b64]=/

{abcd},~hex,b64/hmac-sha1[[{abcd},b64]]

=abcd ~hex hmac[=foo] ?key

~[],?@^#{}


0x01



foo#bar^baz[]
foo;bar|baz()

(foo|bar)|baz

((foo)|bar)|baz

assign var:		?varname
ref var:		#varname
literal:		=value
separator:		" "
file reference:	@filepath

% in url
used in b64: 	_-:!/.+=
shell ok: 		~,.-_{}[]/?%#@^+=:
shell not ok: 	()|!$&*\;'"<>` 

	sh 	b64
`		x
~	x 	x
!	
@	x 	x
#	x 	x
$	 	x
%	x 	x
^	x 	x
&	 	x
*	 	x
()	 	x
-	x 	
_	x 	
=	x 	b
+	x 	
[]	x 	x
{}	x 	x
;	 	x
:	x 	
'		x
"	 	x
,	x 	x
.	x 	
/	x 
<>	 	x
?	x 	x



x(a)|y(b)|z(c)



					z
			
			y				c
	
		x		b

	a

